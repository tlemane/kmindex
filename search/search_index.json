{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to kmindex documentation","text":"<p>kmindex is a tool for indexing and querying sequencing samples. It is built on top of kmtricks.</p> <p>Given a databank \\(D = \\{S_1, ..., S_n\\}\\), with each \\(S_i\\) being any genomic dataset (genome or raw reads), kmindex allows to compute the percentage of shared k-mers between a query \\(Q\\) and each \\(S \\in D\\). It supports multiple datasets and allows searching for each sub-index \\(D_i \\in G = \\{D_1,...,D_m\\}\\). Queries benefit from the findere algorithm. In a few words, findere allows to reduce the false positive rate at query time by querying \\((s+z)\\)-mers instead of \\(s\\)-mers, which are the indexed words, usually called \\(k\\)-mers.</p>"},{"location":"#user-guide","title":"User guide","text":"<ul> <li>Installation</li> <li>Index construction</li> <li>Index query</li> <li>Index merge</li> <li>Index compression</li> </ul>"},{"location":"#server","title":"Server","text":"<ul> <li>Deploy</li> <li>Query</li> </ul> <p>Contact</p> <p>Teo Lemane: teo[dot]lemane[at]genoscope[dot]cns[dot]fr</p>"},{"location":"compression/","title":"Index compression","text":"<p>Since version <code>v0.6.0</code>, <code>kmindex</code> allows to make compressed indexes. It works by dividing an index into blocks, which are then compressed using <code>BlockCompressor</code>. At query time, only the relevant blocks are decompressed.</p>"},{"location":"compression/#kmindex-compress-requires-v060","title":"kmindex compress (requires &gt;= v0.6.0)","text":"<p>Options</p> <pre><code>kmindex compress v0.6.0\n\nDESCRIPTION\n  Compress index.\n\nUSAGE\n  kmindex compress -i/--global-index &lt;STR&gt; -n/--name &lt;STR&gt; [-b/--block-size &lt;INT&gt;] [-s/--sampling &lt;INT&gt;]\n                   [-c/--column-per-block &lt;INT&gt;] [-l/--cpr-level &lt;INT&gt;]\n                   [-t/--threads &lt;INT&gt;] [-v/--verbose &lt;STR&gt;] [-d/--delete] [--check]\n                   [-r/--reorder] [-h/--help] [--version]\n\nOPTIONS\n  [global]\n    -i --global-index - Global index path.\n    -n --name         - Index name.\n    -d --delete       - Delete uncompressed index after compressing. [\u2691]\n       --check        - Check query results after compressing. [\u2691]\n\n  [Reordering options]\n    -b --block-size       - Size of uncompressed blocks, in megabytes. {8}\n    -r --reorder          - Reorder columns before compressing. [\u2691]\n    -s --sampling         - Number of rows to sample for reordering. {20000}\n    -c --column-per-block - Reorder columns by group of N. Should be a multiple of 8 (0=all) {0}\n    -l --cpr-level        - Compression level in [1,22]) {6}\n\n  [common]\n    -t --threads - Number of threads. {22}\n    -h --help    - Show this message and exit. [\u2691]\n       --version - Show version and exit. [\u2691]\n    -v --verbose - Verbosity level [debug|info|warning|error]. {info}\n</code></pre>"},{"location":"compression/#usage","title":"Usage","text":""},{"location":"compression/#basic-compression","title":"Basic compression","text":"<p>The following command compress the index <code>index_1</code> registered in the global index <code>global_index</code> (built using <code>kmindex build</code>, or built with <code>kmtricks</code> and registered with <code>kmindex register</code>, see Index construction).</p> <pre><code>kmindex compress -i ./global_index -n index_1\n</code></pre>"},{"location":"construction/","title":"Index construction","text":""},{"location":"construction/#kmindex-build","title":"kmindex build","text":"<p><code>kmindex build</code> allows to construct an index \\(I\\) from a set of FASTA/Q files (gzipped or not) and register it into a global index \\(G\\). It supports both presence/absence and abundance indexing.</p> <p>Note</p> <p><code>kmindex build</code> is basically a wrapper around kmtricks, ensuring indexes are built in the right way. However, indexes built by <code>kmtricks</code> are usable by <code>kmindex</code> if built using <code>--mode hash:bf:bin</code> (presence/absence mode) or <code>--mode hash:bfc:bin</code> (abundance mode), and without <code>--cpr</code>. Other flags can be used as usual (see kmtricks pipeline). To be queryable, indexes have to be registered into a global index (see <code>kmindex register --help</code>).</p> <p>Options</p> <pre><code>kmindex build v0.6.0\n\nDESCRIPTION\n  Build index.\n\nUSAGE\n  kmindex build -i/--index &lt;STR&gt; -f/--fof &lt;STR&gt; -d/--run-dir &lt;STR&gt; -r/--register-as &lt;STR&gt; [--from &lt;STR&gt;]\n                [--km-path &lt;STR&gt;] [-k/--kmer-size &lt;INT&gt;] [-m/--minim-size &lt;INT&gt;]\n                [--hard-min &lt;INT&gt;] [--nb-partitions &lt;INT&gt;] [--bloom-size &lt;INT&gt;]\n                [--nb-cell &lt;INT&gt;] [--bitw &lt;INT&gt;] [-t/--threads &lt;INT&gt;] [-v/--verbose &lt;STR&gt;]\n                [--cpr] [-h/--help] [--version]\n\nOPTIONS\n  [global]\n    -i --index       - Global index path.\n    -f --fof         - kmtricks input file.\n    -d --run-dir     - kmtricks runtime directory. Use '@inplace' to build inside the global index directory\n    -r --register-as - Index name.\n       --from        - Use parameters from a pre-registered index.\n       --km-path     - Path to kmtricks binary.\n                       - If empty, kmtricks is searched in $PATH and\n                         at the same location as the kmindex binary.\n\n  [kmtricks parameters] - See kmtricks pipeline --help\n    -k --kmer-size     - Size of a k-mer. in [8, 255]) {31}\n    -m --minim-size    - Size of minimizers. in [4, 15] {10}\n       --hard-min      - Min abundance to keep a k-mer. {2}\n       --nb-partitions - Number of partitions (0=auto). {0}\n       --cpr           - Compress intermediate files. [\u2691]\n\n  [presence/absence indexing]\n     --bloom-size - Bloom filter size.\n\n  [abundance indexing]\n     --nb-cell - Number of cells in counting Bloom filter.\n     --bitw    - Number of bits per cell. {2}\n                 - Abundances are indexed by log2 classes (nb classes = 2^{bitw})\n                   For example, using --bitw 3 resulting in the following classes:\n                     0 -&gt; 0\n                     1 -&gt; [1,2)\n                     2 -&gt; [2,4)\n                     3 -&gt; [4,8)\n                     4 -&gt; [8,16)\n                     5 -&gt; [16,32)\n                     6 -&gt; [32,64)\n                     7 -&gt; [64,max(uint32_t))\n\n  [common]\n    -t --threads - Number of threads. {22}\n    -h --help    - Show this message and exit. [\u2691]\n       --version - Show version and exit. [\u2691]\n    -v --verbose - Verbosity level [debug|info|warning|error]. {info}\n</code></pre> <p><code>--from &lt;STR&gt;</code></p> <p>Indexes build using parameters from a pre-registered index can be merged. See <code>kmindex merge</code>.</p>"},{"location":"construction/#input-file-format","title":"Input file format","text":"<p>One sample per line, with a unique ID, and a list of FASTA/Q files separated by semicolons.</p> <p>Example <pre><code>D1: /path/to/D1_1.fasta ; /path/to/D1_2.fasta ; /path/to/D1_3.fasta\nD2: /path/to/D2_1.fasta.gz ; /path/to/D2_2.fasta.gz\n</code></pre></p> <p>An example on how to get such an input fof from a folder containing many input files is: <pre><code>ls -1 folder/*  | sort -n -t/ -k 2 |awk '{print ++count\" : \"$1}' &gt; fof.txt\n</code></pre></p>"},{"location":"construction/#presenceabsence-indexing","title":"Presence/Absence indexing","text":"<p>In presence/absence mode, the index only contains the presence/absence pattern of \\(k\\)-mers in the input samples. As a result, a query response corresponds to shared \\(k\\)-mer ratios between the sequence and each sample contained in the index.</p> <p>Required parameters</p> <ul> <li><code>--index</code>: Path to the global index.</li> <li><code>--fof</code>: Input file, see input file.</li> <li><code>--run-dir</code>: Index output path.</li> <li><code>--register-as</code>: Name of the index.</li> <li><code>--bloom-size</code>: Number of bits in Bloom filters.</li> </ul> <p>Examples</p> <p>The kmindex repository offers an <code>examples</code> directory where these commands can be tested. <pre><code>kmindex build --fof fof1.txt --run-dir D1_index --index ./G --register-as D1 --hard-min 1 --kmer-size 25 --bloom-size 1000000 # (1)!\nkmindex build --fof fof2.txt --run-dir D2_index --index ./G --register-as D2 --hard-min 1 --kmer-size 25 --bloom-size 1000000 # (2)!\n</code></pre></p> <ol> <li>Creates a directory <code>G</code> containing the index for the <code>D1</code> dataset</li> <li>Add the index for the <code>D2</code> dataset in the previously created <code>G</code> directory</li> </ol>"},{"location":"construction/#abundance-indexing","title":"Abundance indexing","text":"<p>In abundance mode, the index associates each \\(k\\)-mer to an abundance class in each sample. The abundance class is computed using log2(\\(k\\)-mer abundance). The number of classes depends on the number of bits (<code>--bitw</code>) used to encode them (\\(2^{bitw}\\)).</p> <p>As a result, a query response corresponds to an abundance class which is the average of all \\(k\\)-mer classes in the query sequence, rounded down to the lowest class.</p> <p>Required parameters</p> <ul> <li><code>--index</code>: Path to the global index.</li> <li><code>--fof</code>: Input file, see input file.</li> <li><code>--run-dir</code>: Index output path.</li> <li><code>--register-as</code>: Name of the index.</li> <li><code>--nb-cell</code>: Number of cells in Counting Bloom filters.</li> <li><code>--bitw</code>: Number of bits per cell (nb classes = \\(2^{bitw}\\)).</li> </ul> <p>Examples</p> <pre><code>kmindex build --fof fof1.txt --run-dir D1_index --index ./G --register-as D1 --hard-min --kmer-size 25 --nb-cell 1000000 --bitw 2 # (1)!\nkmindex build --fof fof2.txt --run-dir D2_index --index ./G --register-as D2 --hard-min --kmer-size 25 --nb-cell 1000000 --bitw 4 # (2)!\n</code></pre> <ol> <li>D1 is indexed using 4 abundance classes.</li> <li>D2 is indexed using 16 abundance classes.</li> </ol>"},{"location":"construction/#about-bloom-filter-size","title":"About Bloom filter size","text":"<p>kmindex relies on Bloom filters, a probabilistic data structure exposed to false postives. The false positive rate, \\(\\epsilon\\), depends the number of bits in the Bloom filter, the number of elements to insert (the number of \\(k\\)-mers) and the number of hash functions (always 1 here). The cardinality of your samples can be quickly estimated using ntCard. The Bloom filter size should then be choosen according to the sample containing the largest number of \\(k\\)-mers.</p> <p>Tip</p> <p>Some online tools can help: https://hur.st/bloomfilter/</p> <p>Note that kmindex benefits from the findere algorithm, a query-time technique allowing to drastically reduce the false positive rates. An approximation of the false positive rate under findere is \\(\\epsilon^z\\), where \\(z\\) is a query-time parameter (which cannot be arbitrary large, see z help and findere paper). It is recommended to choose your filter size according to this point.</p>"},{"location":"installation/","title":"kmindex installation","text":"<p>Note</p> <p>kmindex supports GNU/Linux systems, and macOS since v0.5.2.</p>"},{"location":"installation/#conda","title":"Conda","text":"<pre><code>conda create -p kmindex_env\nconda activate ./kmindex_env\nconda install -c conda-forge -c tlemane kmindex\n</code></pre> <p>Note that the conda package includes kmtricks.</p>"},{"location":"installation/#docker","title":"Docker","text":"<pre><code>docker pull tlemane/kmindex\n</code></pre>"},{"location":"installation/#nix","title":"Nix","text":"<pre><code>  nix --extra-experimental-features 'nix-command flakes' build github:tlemane/kmindex\n</code></pre>"},{"location":"installation/#release","title":"Release","text":"<p>Portable binary releases are available at kmindex/releases.</p> <p> </p>"},{"location":"installation/#install-from-sources","title":"Install from sources","text":"<p>Requirements</p> <ul> <li>cmake &gt;= 3.13</li> <li>gcc &gt;= 8.1</li> <li>Boost.Asio and Boost.System &gt;= 1.70</li> <li>bzip2</li> </ul> <p>All other dependencies are bundled with <code>kmindex</code>.</p> <p>Installation <pre><code>git clone --recursive https://github.com/tlemane/kmindex # (1)!\ncd kmindex &amp;&amp; ./install.sh # (2)!\n</code></pre></p> <ol> <li>Cloning the repository</li> <li>Build kmindex using <code>install.sh</code></li> </ol> <p><code>install.sh</code></p> <pre><code>kmindex build script - v0.5.0.\nUsage:\n  ./install.sh [-r str] [-t int] [-j int] [-p str] [-k int] [-n] [-h]\nOptions:\n  -r &lt;Release|Debug&gt; -&gt; build type {Release}.\n  -t &lt;0|1|2&gt;         -&gt; tests: 0 = disabled, 1 = compile, 2 = compile and run {0}.\n  -j &lt;INT&gt;           -&gt; nb threads {8}.\n  -k &lt;INT&gt;           -&gt; Max k-mer size (should be a multiple of 32) {256}\n  -n                 -&gt; portable x86-64 build {disabled}.\n  -p                 -&gt; install path {./kmindex_install}\n  -h                 -&gt; show help.\n</code></pre>"},{"location":"merge/","title":"Merge","text":"<p>In addition to registering multiple indexes, compatible sub-indexes (i.e. sharing the parameters: k-mer size, Bloom filter size, number of partitions) can also be merged. This way, the indexes are physically extended resulting in optimal query times.</p> <p>Options</p> <pre><code>kmindex merge v0.6.0\n\nDESCRIPTION\n  Merge sub-indexes.\n\nUSAGE\n  kmindex merge -i/--index &lt;STR&gt; -n/--new-name &lt;STR&gt; -p/--new-path &lt;STR&gt; -m/--to-merge &lt;LIST[STR]&gt;\n                [-r/--rename &lt;STR&gt;] [-t/--threads &lt;INT&gt;] [-v/--verbose &lt;STR&gt;]\n                [-d/--delete-old] [-h/--help] [--version]\n\nOPTIONS\n  [global]\n    -i --index      - Global index path.\n    -n --new-name   - Name of the new index.\n    -p --new-path   - Output path.\n    -m --to-merge   - Sub-indexes to merge, comma separated.\n    -d --delete-old - Delete old sub-index files. [\u2691]\n    -r --rename     - Rename sample ids.\n                      - A sub-index cannot contain samples with similar identifiers.\n                        Sub-indexes containing identical identifiers cannot be merged, the\n                        identifiers must be renamed.\n                      - Renaming can be done in three different ways:\n\n                        1. Using identifier files (one per line).\n                           For example, if you want to merge three sub-indexes:\n                             '-r f:id1.txt,id2.txt,id3.txt'\n\n                        2. Using a format string ('{}' is replaced by an integer in [0, nb_samples)).\n                             '-r \"s:id_{}\"'\n\n                        3. Manually (not recommended).\n                           Identifiers can be changed in 'kmtricks.fof' files in sub-index directories.\n\n  [common]\n    -t --threads - Number of threads. {22}\n    -h --help    - Show this message and exit. [\u2691]\n       --version - Show version and exit. [\u2691]\n    -v --verbose - Verbosity level [debug|info|warning|error]. {info}\n</code></pre>"},{"location":"python-api/","title":"Python API","text":"<p>The python API allows to query a running kmindex server. In the following, we assume that a server is running at 127.0.0.1 on port 8080.</p>"},{"location":"python-api/#installation","title":"Installation","text":"<p>Requirements</p> <ul> <li>python &gt;= 3.10</li> <li>pip (with PEP-517 support if installing from sources)</li> </ul>"},{"location":"python-api/#using-pip","title":"Using pip","text":"<pre><code>pip install pykmindex\n</code></pre>"},{"location":"python-api/#from-sources","title":"From sources","text":"<pre><code>pip install git+https://github.com/tlemane/kmindex.git#subdirectory=pykmindex\n</code></pre>"},{"location":"python-api/#usage","title":"Usage","text":""},{"location":"python-api/#connection","title":"Connection","text":"<pre><code>from pykmindex.server import connect\n\nkm_serv = connect(\"127.0.0.1\", 8080)\n\ninfos = km_serv.infos()\n</code></pre>"},{"location":"python-api/#query","title":"Query","text":""},{"location":"python-api/#synchronous","title":"Synchronous","text":"<pre><code>from Bio import SeqIO\n\nfrom pykmindex.server import connect\nfrom pykmindex.query import Query\n\nkm_serv = connect(\"127.0.0.1\", 8080)\n\nfor record in SeqIO.parse(\"query.fa\", \"fasta\"):\n    res = km_serv.submit(Query(record.id,\n                               record.seq, # Can be a list of sequences\n                               \"index_id\", # Can be a list of sub-indexes to query\n                               0.0,        # Min ratio to report a result (optional, default 0.0)\n                               3))         # z value (optional, default 3)\n    if res:\n        print(res.id, res.result)\n    else:\n        print(res.err)\n</code></pre>"},{"location":"python-api/#asynchronous","title":"Asynchronous","text":"<p>Using QBatch</p> <pre><code>from Bio import SeqIO\nfrom pykmindex.server import connect\nfrom pykmindex.query import QBatch\n\nkm_serv = connect(\"127.0.0.1\", 8080)\n\nbatch = QBatch()\n\nfor record in SeqIO.parse(\"query.fa\", \"fasta\"):\n    batch.add(record.id, record.seq, \"index_id\")\n\nresponses = km_serv.submit_async(batch)\n\nfor r in responses:\n    if r:\n        print(r.id, r.result)\n    else:\n        print(r.err)\n</code></pre> <p>Using your own event loop</p> <pre><code>import asyncio\nfrom Bio import SeqIO\nfrom pykmindex.server import connect\nfrom pykmindex.query import Query\n\nkm_serv = connect(\"127.0.0.1\", 8080)\n\nfutures = []\nfor record in SeqIO.parse(\"query.fa\", \"fasta\"):\n    futures.append(km_serv.async_query(Query(record.id, record.seq, \"index_id\")))\n\nloop = asyncio.new_event_loop()\nasyncio.set_event_loop(loop)\nresponses = loop.run_until_complete(asyncio.gather(*futures))\n\nfor r in responses:\n    if r:\n        print(r.id, r.result)\n    else:\n        print(r.err)\n</code></pre>"},{"location":"query/","title":"Index query","text":""},{"location":"query/#kmindex-query","title":"kmindex query","text":"<p>kmindex query allows to query all sequences in FASTA/Q file (gz/bz2) against all sub-indexes registered into a global index \\(G\\). For each sequence, the output is a list of either shared \\(k\\)-mer ratios (presence/absence mode) or abundance classes (abundance mode).</p> <p>Options</p> <pre><code>kmindex query v0.6.0\n\nDESCRIPTION\n  Query index.\n\nUSAGE\n  kmindex query -i/--index &lt;STR&gt; -q/--fastx &lt;STR&gt; [-n/--names &lt;STR&gt;] [-z/--zvalue &lt;INT&gt;]\n                [-r/--threshold &lt;FLOAT&gt;] [-o/--output &lt;STR&gt;] [-s/--single-query &lt;STR&gt;]\n                [-f/--format &lt;STR&gt;] [-b/--batch-size &lt;INT&gt;] [-t/--threads &lt;INT&gt;]\n                [-v/--verbose &lt;STR&gt;] [-a/--aggregate] [--fast] [-h/--help] [--version]\n\nOPTIONS\n  [global]\n    -i --index        - Global index path.\n    -n --names        - Sub-indexes to query, comma separated. {all}\n    -z --zvalue       - Index s-mers and query (s+z)-mers (findere algorithm). {0}\n    -r --threshold    - Shared k-mers threshold. in [0.0, 1.0] {0.0}\n    -o --output       - Output directory. {output}\n    -q --fastx        - Input fasta/q file (supports gz/bzip2) containing the sequence(s) to query.\n    -s --single-query - Query identifier. All sequences are considered as a unique query.\n    -f --format       - Output format [json|matrix|json_vec|jsonl|jsonl_vec] {json}\n    -b --batch-size   - Size of query batches (0\u2248nb_seq/nb_thread). {0}\n    -a --aggregate    - Aggregate results from batches into one file. [\u2691]\n       --fast         - Keep more pages in cache (see doc for details). [\u2691]\n\n  [common]\n    -t --threads - Number of threads. {1}\n    -h --help    - Show this message and exit. [\u2691]\n       --version - Show version and exit. [\u2691]\n    -v --verbose - Verbosity level [debug|info|warning|error]. {info}\n</code></pre> <p>--single-query &lt;STR&gt;</p> <p>All sequences in an input file can be considered a unique query by using <code>--single-query query_name</code>. The output file contains then shared \\(k\\)-mer ratios between the input file and each indexed sample. This corresponds to the query behavior of kmindex-server (see server-query)</p> <p>--batch-size &lt;INT&gt;</p> <p>The number of queries in memory is actually <code>batch-size</code>\\(\\times\\)<code>threads</code>.</p>"},{"location":"query/#presenceabsence-query","title":"Presence/Absence query","text":"<p>Main parameters</p> <ul> <li><code>--index &lt;STR&gt;</code>: Path to global index.</li> <li><code>--fastx &lt;STR&gt;:</code> File containing queries.</li> <li><code>--names &lt;[STR]&gt;</code>: Sub-indexes to query, comma separated.</li> <li><code>--zvalue &lt;INT&gt;</code>: Usually in \\([0,6]\\), see findere algorithm.</li> <li><code>--threshold &lt;FLOAT&gt;</code>: Report only ratios &gt; <code>threshold</code>, in \\([0.0,1.0]\\).</li> </ul> <p>Example: Querying sequence <code>1</code> and <code>2</code> from <code>query.fasta</code> against the presence/absence index \\(D1\\). The kmindex repository offers an <code>examples</code> directory where these commands can be tested.</p> <pre><code>kmindex query --index ./G --fastx query.fasta --names D1 --zvalue 3 --threshold 0 # (1)!\n</code></pre> <ol> <li>Several indexes can be queried at the same time by using <code>--names D1,D2,...</code>.</li> </ol> <p>The results are shared ratios between queries and each sample indexed in \\(D1\\). See Output formats.</p>"},{"location":"query/#output-formats","title":"Output formats","text":"<p>JSON (<code>--format json</code>)</p> <pre><code>{\n    \"D1\": {\n        \"1\": {\n            \"S1\": 1.0,\n            \"S2\": 0.0\n        },\n        \"2\": {\n            \"S1\": 1.0,\n            \"S2\": 0.0\n        }\n    }\n}\n</code></pre> <p>JSONL (<code>--format jsonl</code>)</p> <pre><code>{\"index\":\"D1\", \"query\":\"1\", \"samples\":{\"S1\": 1.0,\"S2\":0.0}}\n{\"index\":\"D1\", \"query\":\"2\", \"samples\":{\"S1\": 1.0,\"S2\":0.0}}\n</code></pre> <p>TSV (<code>--format matrix</code>)</p> <pre><code>D1     S1   S2\nD1:1  1.0  0.0\nD1:2  1.0  0.0\n</code></pre>"},{"location":"query/#abundance-query","title":"Abundance query","text":"<p>The query mode is automatically determined by the index type. The values reported in the output files are simply abundance classes instead of shared \\(k\\)-mer ratios.</p>"},{"location":"query/#about-the-z-parameter","title":"About the <code>z</code> parameter","text":"<p>findere is a query-time technique allowing to reduce the false positive rate of an arbitrary AMQF (as Bloom filters) while reducing the number of lookups to resolve a query. Its scope concerns the indexing of objects that are decomposable into sub-objects, i.e. a sequence of characters. It is based on the following straightforward statement: if a sequence \\(S \\in E\\), then its sub-words \\(w_i \\in E\\).</p> <p>To benefit from findere, small \\(k\\)-mers are actually indexed (\\(s\\)-mer), and (\\(s+z\\))-mers are considered are query time. As a result, for a given false positive rate of \\(\\epsilon\\), the probability of a false match becomes \\(\\epsilon^z\\) at query time, reducing the false postive rate by several orders of magnitude. Note that \\(z\\) cannot be arbitrary large, usually \\(z \\in [0, 6]\\), see findere paper for more details.</p>"},{"location":"server-deploy/","title":"Server deploy","text":""},{"location":"server-deploy/#kmindex-server","title":"kmindex-server","text":"<p>For easy integration, kmindex is also composed of a server supporting http requests. The server can be started using the kmindex-server binary, see options below.</p> <p>Options</p> <pre><code>kmindex-server v0.5.2\n\nDESCRIPTION\n  kmindex-server allows to perform queries via POST requests.\n\nUSAGE\n  kmindex-server -i/--index &lt;STR&gt; [-a/--address &lt;STR&gt;] [-p/--port &lt;INT&gt;] [-d/--log-directory &lt;STR&gt;]\n                 [-t/--threads &lt;INT&gt;] [--verbose &lt;STR&gt;] [-s/--no-stderr] [-h/--help]\n                 [--version]\n\nOPTIONS\n  [global] - global parameters\n    -i --index         - Index path.\n    -a --address       - Address to use (empty string to bind any address)\n                             IPv4: dotted decimal form\n                             IPv6: hexadimal form.\n                             default -&gt;  {127.0.0.1}\n    -p --port          - Port to use. {8080}\n    -d --log-directory - Directory for daily logging. {kmindex_logs}\n    -s --no-stderr     - Disable stderr logging. [\u2691]\n\n  [common]\n    -t --threads - Max number of parallel connections. {1}\n    -h --help    - Show this message and exit. [\u2691]\n       --version - Show version and exit. [\u2691]\n       --verbose - Verbosity level [debug|info|warning|error]. {info}\n</code></pre>"},{"location":"server-query/","title":"Server query","text":"<p>In the following, we assume that a kmindex-server is running at 127.0.0.1 on port 8080.</p> Method Description Path <code>GET</code> Index informations /kmindex/infos <code>POST</code> Index query /kmindex/query"},{"location":"server-query/#accessing-index-information","title":"Accessing index information","text":"<p>Request <pre><code>curl -X GET http://127.0.0.1:8080/kmindex/infos\n</code></pre></p> <p>Response <pre><code>{\n    \"index\": {\n        \"D1\": {\n            \"bloom_size\": 10000128,\n            \"index_size\": 9,\n            \"minim_size\": 10,\n            \"nb_partitions\": 4,\n            \"nb_samples\": 2,\n            \"samples\": [\n                \"S1\",\n                \"S2\"\n            ],\n            \"smer_size\": 25\n        },\n        \"D2\": {\n            \"bloom_size\": 10000128,\n            \"index_size\": 9,\n            \"minim_size\": 10,\n            \"nb_partitions\": 4,\n            \"nb_samples\": 2,\n            \"samples\": [\n                \"S3\",\n                \"S4\"\n            ],\n            \"smer_size\": 25\n        }\n    }\n</code></pre></p>"},{"location":"server-query/#query-index","title":"Query index","text":"<p>json body</p> <ul> <li><code>index</code>: An array of strings corresponding to the indexes to query.</li> <li><code>id</code>: A string used as query identifier.</li> <li><code>seq</code>: An array of strings corresponding to the sequences to query. All sequences are considered as a unique query (same as <code>kmindex query --single-query &lt;STR&gt;</code>).</li> <li><code>fastx</code>: A string containing sequences in fasta/q format.</li> <li><code>format</code>: A string in [\"json\", \"tsv\"] corresponding to the output format.</li> <li><code>z</code>: The z parameter, see z help (default: 0).</li> <li><code>r</code>: A float in \\([0,1]\\), all ratios greater than <code>r</code> are reported (default: 0).</li> </ul> <p><code>seq</code> and <code>fastx</code> are mutually exclusive.</p> <p>Request</p> <pre><code>curl -X POST http://127.0.0.1:8080/kmindex/query \\\n     -H 'Content-type: application/json' \\\n     -d '{\"index\":[\"D1\"],\"seq\":[\"ACGACGACGACGAGACGAGACGACAGCAGACAGAGACATAATATACT\"], \"id\":\"ID\",\"z\":3}' # (1)!.\n</code></pre> <ol> <li>To avoid curl to change POST requests to GET on redirection, use <code>--post302</code>.</li> </ol> <p>Response</p> <pre><code>{\n    \"D1\": {\n        \"ID\": {\n            \"S1\": 1.0,\n            \"S2\": 0.0\n        },\n    }\n}\n</code></pre>"}]}